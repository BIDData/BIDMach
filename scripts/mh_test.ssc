:silent

/**
 * This will test using the MH Test Updater. The code here:
 *  
 * - Loads a dataset (not on GitHub). Note: here data are 0s and 1s.
 * - Defines its own learner which uses the new updater
 * - Then runs GLM with logistic regression
 *
 * - CRITICAL: we don't yet have the data augmentation done correctly!
 */

val tr = loadFMat("/home/daniel/data/FINAL_MNIST8M_TRAIN_100000.fmat.lz4")
val te = loadFMat("/home/daniel/data/FINAL_MNIST8M_TEST_20000.fmat.lz4")

val tr_data = tr(0->784,?)
val tr_labels = tr(784,?)
tr_labels(find(tr_labels == -1)) = 0

val te_data = te(0->784,?)
val te_labels = te(784,?)
te_labels(find(te_labels == -1)) = 0

:silent
// Logistic regression from GLM, type=1, with test data pre-loaded.
// mm = the training learner (model, datasource, updater), with options mopts
// nn = the predicting learner, with options nopts

import BIDMach.models.GLM._
import BIDMach.updaters._

// Basic in-memory GLM learner with explicit target matrix and d=1 for Logistic-Reg.
// I'm going to use the MHTest(mopts) here, with mostly default settings.
def learner(mat0:Mat, targ:Mat, d:Int) = {
    class LearnOptions extends Learner.Options with GLM.Opts with MatSource.Opts with MHTest.Opts with ADAGrad.Opts with L1Regularizer.Opts
    val mopts = new LearnOptions;
    if (mopts.links == null) mopts.links = izeros(1,targ.nrows)
    mopts.links.set(d)
    val model = new GLM(mopts)
    val mm = new Learner( 
        new MatSource(Array(mat0, targ), mopts), 
        model, 
        mkRegularizer(mopts),
        //new Grad(mopts),
        new MHTest(mopts), 
        null,
        mopts)
    (mm, mopts)
}

val (mm, mopts) = learner(tr_data, tr_labels, 1)
mopts.addConstFeat = false
mopts.npasses = 5
mopts.batchSize = 100
mopts.lrate = 0.01
mopts.matrixOfScores = true // This is required for the MH Test to work.
mopts.verboseMH = false // Set to true if debugging.
mopts.what
val model = mm.model.asInstanceOf[GLM]
mm.train

val (nn, nopts) = GLM.predictor(model, te_data)
nopts.addConstFeat = false
nopts.batchSize = 1000
nopts.links = nopts.links
nn.predict

// Now evaluate performance by setting 0.5 as the cutoff.
:silent
val te_preds = FMat(nn.preds(0))
te_preds(find(te_preds < 0.5)) = 0
te_preds(find(te_preds >= 0.5)) = 1
:silent

val accuracy = (te_labels == te_preds).nnz.toFloat / (te_preds.nrows*te_preds.ncols)
print("\nAccuracy at a decision threshold of 0.5: %.4f\n" format accuracy)
sys.exit
