import BIDMach.networks.layers._
import BIDMach.io.Onnx
import scala.collection.mutable.HashMap


//val modelname = "bvlc_reference_caffenet"
val modelname = "squeezenet"
val modelFile = "/code/onnx/models/"+modelname+"/"+modelname+"/model.onnx";
val batchSize = 64;

val traindir = "../../data/ImageNet/train/";
val testdir = "../../data/ImageNet/val/";
val traindata = traindir+"partNCHW%04d.bmat.lz4";
val trainlabels = traindir+"label%04d.imat.lz4";
val testdata = testdir+"partNCHW%04d.bmat.lz4";
val testlabels = testdir+"label%04d.imat.lz4";
val testpreds = testdir+"pred%04d.fmat.lz4";


val frontEnd = new NodeSet(4);

val means = ones(3\256\256\batchSize) *@ loadFMat(traindir+"means.fmat.lz4");

// The input layers for the network
frontEnd(0) = new InputNode;
frontEnd(1) = new ConstantNode{value=means};
frontEnd(2) = new SubNode{inputs(0)=frontEnd(0); inputs(1)=frontEnd(1)};
frontEnd(3) = new CropNode{inputs(0)=frontEnd(2);}

// How to find the data input tensor:
val dataLink = new HashMap[String,Int];
val dataname = "data_0"
dataLink(dataname) = 3;

println("Reading Model")
val onnx = new Onnx
val (nodes, modelmats) = onnx.readModel(modelFile, frontEnd, dataLink)
modelmats(0) = Onnx.fromRGBtoBGR(modelmats(0))

println("Starting Predictor")

val opts = new Net.FilePredOptions
val net0 = new Net(opts)
net0.setmodelmats(modelmats)
opts.nodeset=nodes

val (mm, mopts) =  Net.predLabels(net0, testdata, testlabels);
mopts.tensorFormat = Net.TensorNCHW;
mopts.inplace = Net.BackwardCaching;
mopts.inplace = Net.NoInPlace
mopts.convType = Net.CrossCorrelation;
//mopts.convType = Net.Convolution;
mopts.batchSize= batchSize
mopts.autoReset = false
mopts.hasBias = true
    
val net = mm.model.asInstanceOf[Net];
mm.predict; 


println("Done")


