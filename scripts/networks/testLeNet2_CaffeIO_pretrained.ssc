//:silent
import BIDMach.extern._
import BIDMach.networks.layers._
import java.io.FileInputStream

val traindir = "../../data/MNIST/"

val train0 =       loadIDX(traindir+"train-images-idx3-ubyte").reshapeView(1,28,28,60000);
val trainlabels0 = loadIDX(traindir+"train-labels-idx1-ubyte").reshapeView(1,60000);
val test =         loadIDX(traindir+"t10k-images-idx3-ubyte").reshapeView(1,28,28,10000);
val testlabels =   loadIDX(traindir+"t10k-labels-idx1-ubyte").reshapeView(1,10000);

val rp = randperm(60000);
val train = train0(?,?,?,rp);
val trainlabels = trainlabels0(?,rp);

val mt = train.mean(irow(3));
train ~ train - mt;
test ~ test - mt;

// TODO: eliminate need to instantiate learner first
val (nn,opts) = Net.learner(train,trainlabels);


opts.batchSize= 64
opts.npasses = 2

opts.lrate = 1e-3f 
opts.texp = 0.3f
opts.pstep = 0.1f
opts.hasBias = true;
opts.tensorFormat = Net.TensorNCHW;
//opts.autoReset = false;

var f:FileInputStream = null
var nodeSet:NodeSet = null
var modelMats:Array[Mat] = null
try {
  f = new FileInputStream("lenet_iter_10000.caffemodel")
  val (x, y) = CaffeIO.loadModelFromProtobuf(f)
  nodeSet = x
  modelMats = y
} finally {
  if (f != null) {
    f.close()
  }
}

// XXX this appears to be missing support in the protobuf
nodeSet(8).asInstanceOf[SoftmaxOutputNode].scoreType = SoftmaxOutputLayer.AccuracyLoss




opts.nodeset = nodeSet;
val model = nn.model.asInstanceOf[Net];
opts.nmodelmats = modelMats.length
model.copyModelMats(modelMats)

val (mm, mopts) = Net.predictor(model, test, testlabels);
mopts.batchSize = 64;
val mmodel = mm.model.asInstanceOf[Net];
mm.predict;

println("Accuracy = %f" format mean(mm.results(0,?),2).v);

//:silent

