:silent
val traindir = "../../data/ImageNet/train/"
val testdir = "../../data/ImageNet/test/"

val (nn,opts) = Net.learner(traindir+"parts%04d.fmat.lz4",traindir+"labels%04d.fmat.lz4");

opts.nend = 100
opts.batchSize= 128
opts.npasses = 4
opts.lrate = 0.01f 
opts.texp = 0.3f
opts.pstep = 0.001f
opts.links = iones(1,1);
opts.nweight = 1e-4f;
opts.lookahead = 0;

import BIDMach.networks.layers.Node._;

val in = input;
val means = input;
val crop1 = crop(in);
val diff1 = crop1 - means;
val fmt1 = format(diff1);

val conv1 = conv(fmt1)(w=7,h=7,nch=64,stride=4,pad=3);
val bn1 = batchNormScale(conv1);
val relu1 = relu(bn1);

val conv2 = conv(relu1)(w=5,h=5,nch=256,stride=2,pad=2);
val bn2 = batchNormScale(conv2);
val relu2 = relu(bn2);

val conv3 = conv(relu2)(w=3,h=3,nch=256,stride=1,pad=1);
val bn3 = batchNormScale(conv3);
val relu3 = relu(bn3);

val conv4 = conv(relu3)(w=5,h=5,nch=1024,stride=2,pad=2);
val bn4 = batchNormScale(conv4);
val relu4 = relu(bn4);

val conv5 = conv(relu4)(w=3,h=3,nch=1024,stride=1,pad=1);
val bn5 = batchNormScale(conv5);
val relu5 = relu(bn5);

val conv6 = conv(relu5)(w=3,h=3,nch=1024,stride=1,pad=1);
val bn6 = batchNormScale(conv6);
val relu6 = relu(bn6);

val fc7 = lin(relu6)(outdim=4096);
val relu7 = relu(fc7);

val fc8 = lin(relu7)(outdim=4096);
val relu8 = relu(fc8);

val fc9 = lin(relu8)(outdim=1000);
val out = glm(fc9)(opts.links);

val layers = Array(in, means, crop1, diff1, fmt1, conv1, bn1, relu1, conv2, bn2, relu2, conv3, bn3, relu3, conv4, bn4, relu4,
                   conv5, bn5, relu5, conv6, bn6, relu6, fc7, relu7, fc8, relu8, fc9, out);

opts.nodeset = new NodeSet(layers);
val model = nn.model.asInstanceOf[Net];
nn.train;

val (mm, mopts) =  Net.predictor(model,testdir+"parts%04d.fmat.lz4",testdir+"preds%04d.fmat.lz4");
mm.predict;


:silent

