:silent
import BIDMach.models.SMF

/**
 * Test SMF code on netflix data. This will use OUR MHTest updater, which I put
 * in as a new updater (SMF.learner2) to make this script more concise. Some
 * notes on the netflix dataset:
 *
 * size(a) = (17770,480189)
 * a.nnz = 90430138
 * min=0, max=5
 * 
 * (a == 1).nnz = 4156151
 * (a == 2).nnz = 9120198
 * (a == 3).nnz = 25928920
 * (a == 4).nnz = 30375037
 * (a == 5).nnz = 20849832
 * mean (of nonzeros) = 3.6042476
 * sqrt((diff ddot diff) / diff.nn) = 1.0852 // Train RMSE using mean predictor
 *
 * (ta == 1).nnz = 461839
 * (ta == 2).nnz = 1011882
 * (ta == 3).nnz = 2882327
 * (ta == 4).nnz = 3375921
 * (ta == 5).nnz = 2318400
 * mean (of nonzeros) = 3.6046705
 * sqrt((diff ddot diff) / diff.nn) = 1.0851 // Test RMSE using mean predictor
 *
 * BTW: (a *@ ta).nnz = 0, which shows that they are completely distinct.
 */

// Same code as in the ADAGrad-only script.
setseed(0)
val dir = "/data/netflix/"
val a = loadSMat(dir+"newtrain.smat.lz4")
val ta = loadSMat(dir+"newtest.smat.lz4")
val d = 256
val lrates = row(0.01)
val langs = sqrt(2f * lrates) // NEW! MALA so it's sqrt(2 * lr).
var bestrmse = 10.0;
var prettystring = "lrate   lang.   arate   rmse\n"

for (i <- 0 until lrates.length) {
    for (k <- 0 until 1) {
        val (nn,opts) = SMF.learner2(a, d)

        // Common parameters with the ADAGrad version.
        opts.batchSize = 1000
        opts.npasses = 1
        opts.nesterov = null
        opts.langevin = langs(k).v
        opts.momentum = null

        opts.uiter = 5
        opts.urate = 0.05f
        opts.lrate = lrates(i).v
        val lambda = 4f       
        opts.lambdau = lambda
        opts.regumean = lambda
        opts.lambdam = lambda / 500000 * 20
        opts.regmmean = opts.lambdam
        opts.evalStep = 31
        opts.doUsers = false

        // Now some stuff specific for the MHTest+ADAGrad.
        opts.smf = true
        opts.saveAcceptRate = true
        opts.acceptRateDir = "tmp/"
        opts.N = a.nnz
        opts.temp = a.nnz / 1000
        opts.Nknown = true
        opts.n2lsigma = 1.0f
        opts.nn2l = 4000
        opts.sigmaProposer = 0.01f
        opts.continueDespiteFull = false
        opts.verboseMH = true
        opts.collectData = false
        opts.collectDataDir = "tmp/"
        opts.exitTheta = false
        opts.initThetaHere = true
        opts.burnIn = -1
        opts.matrixOfScores = true
        opts.what
        nn.train
        
        val model = nn.model.asInstanceOf[SMF]
        val xa = (ta != 0)
        val (mm, mopts) = SMF.predictor1(model, a, xa)
        mopts.batchSize = 10000
        mopts.uiter = 5
        mopts.urate = opts.urate
        mopts.aopts = null
        mm.predict
        
        val pa = SMat(mm.preds(1));
        println("Note: max(pa)="+maxi(maxi(pa))+" and min(pa)="+mini(mini(pa)))
        val diff = ta.contents - pa.contents
        val rmse = sqrt((diff ddot diff) / diff.length)
        println("\nrmse = %f" format rmse.v)
        min(pa.contents,5,pa.contents)
        max(pa.contents,1,pa.contents)
        val diff2 = ta.contents - pa.contents
        val rmse2 = sqrt((diff2 ddot diff2) / diff2.length)
        println("rmse (w/clipping) = %f\n" format rmse2.v)

        val accepts = loadMat(opts.acceptRateDir+"arate_%1.4f_%1.3f.mat.lz4" format (lrates(i).v,langs(k).v))
        val arate = accepts.nnz / accepts.length.toFloat

        if (rmse2.v < bestrmse) {
            bestrmse = rmse2.v
        }   
        prettystring += "%1.5f  %1.3f  %1.4f  %1.4f\n" format (lrates(i).v,langs(k).v,arate,rmse2.v)
    }
}

println("\nBest RMSE: "+bestrmse+ "\n")
println(prettystring)
sys.exit
