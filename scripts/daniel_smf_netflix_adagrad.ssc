:silent
import BIDMach.models.SMF

/**
 * Test SMF code on netflix data. This will use default ADAGrad. In general,
 * RMSEs of roughly 0.83 to 0.85 are "good".
 */

// Same code as in the MHTest+ADAGrad script.
setseed(0)
val dir = "/data/netflix/"
val a = loadSMat(dir+"newtrain.smat.lz4")
val ta = loadSMat(dir+"newtest.smat.lz4")
val d = 256
val lrates = row(0.0001, 0.001, 0.01, 0.1)
val momens = row(0.5, 0.75, 0.9, 0.95, 0.99)
val langs = row(0.0, 0.05, 0.5)
var bestrmse = 10.0;
var prettystring = "moment.  lrate  lang.  rmse\n"

for (i <- 0 until lrates.length) {
    for (j <- 0 until momens.length) {
        for (k <- 0 until langs.length) {
            val (nn,opts) = SMF.learner1(a, d)

            // Common parameters with the MHTest+ADAGrad version.
            opts.batchSize = 1000
            opts.npasses = 2
            opts.momentum = momens(j)
            opts.nesterov = null
            opts.langevin = langs(k).v
            
            opts.uiter = 5
            opts.urate = 0.05f
            opts.lrate = lrates(i).v
            val lambda = 4f
            opts.lambdau = lambda
            opts.regumean = lambda
            opts.lambdam = lambda / 500000 * 20
            opts.regmmean = opts.lambdam
            opts.evalStep = 31
            opts.doUsers = false
            opts.what
            nn.train
            
            val model = nn.model.asInstanceOf[SMF]
            val xa = (ta != 0)
            val (mm, mopts) = SMF.predictor1(model, a, xa)
            mopts.batchSize = 10000
            mopts.uiter = 5
            mopts.urate = opts.urate
            mopts.aopts = null
            mm.predict
            
            val pa = SMat(mm.preds(1));
            println("Note: max(pa)="+maxi(maxi(pa))+" and min(pa)="+mini(mini(pa)))
            val diff = ta.contents - pa.contents
            val rmse = sqrt((diff ddot diff) / diff.length)
            println("\nrmse = %f" format rmse.v)
            min(pa.contents,5,pa.contents)
            max(pa.contents,1,pa.contents)
            val diff2 = ta.contents - pa.contents
            val rmse2 = sqrt((diff2 ddot diff2) / diff2.length)
            println("rmse (w/clipping) = %f\n" format rmse2.v)

            if (rmse2.v < bestrmse) {
                bestrmse = rmse2.v
            }
            prettystring += "%1.3f  %1.5f  %1.3f  %1.4f\n" format (momens(j).v,lrates(i).v,langs(k).v,rmse2.v)
        }
    }
}

println("\nBest RMSE: "+bestrmse+ "\n")
println(prettystring)
sys.exit
