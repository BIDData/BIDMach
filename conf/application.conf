akka {
  actor {
    provider = "cluster"
    serializers {
      java = "akka.serialization.JavaSerializer"
      proto = "akka.remote.serialization.ProtobufSerializer"
      kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
    }
    serialization-bindings {
      "java.io.Serializable" = kryo
      "com.google.protobuf.Message" = proto
    }
    kryo  {
      # Possibles values for type are: graph or nograph
      type = "graph"
      # Possible values for idstrategy are:
      # default, explicit, incremental, automatic
      idstrategy = "default"
      # Define a default size for byte buffers used during serialization
      buffer-size = 4096
      max-buffer-size = -1
      use-manifests = false
      # If set it will use the UnsafeInput and UnsafeOutput
      # The unsafe IO usually creates bigger payloads but is faster
      # for some types, e.g. native arrays.
      use-unsafe = true
      # post-serialization-transformations = "lz4"
      # Settings for aes encryption, if included in transformations AES
      # encryption {
      #    aes {
      #        mode = "AES/CBC/PKCS5Padding"
      #        key = j68KkRjq21ykRGAQ
      #        IV-length = 16
      #    }
      # }
      # Log implicitly registered classes. Useful, if you want to know all
      implicit-registration-logging = false
      # If enabled, Kryo logs a lot of information about serialization process.
      kryo-trace = false
      # If proviced, Kryo uses the class specified by a fully qualified
      # kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"
      # If enabled, allows Kryo to resolve subclasses of registered Types.
      resolve-subclasses = false
    }
  }
  remote {
    log-remote-lifecycle-events = off
    netty.tcp {
      hostname = "127.0.0.1"
      port = 0
    }
  }
  cluster {
    seed-nodes = [
      "akka.tcp://ClusterSystem@127.0.0.1:2551",
      "akka.tcp://ClusterSystem@127.0.0.1:2552"]
  }
  extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]
  loglevel = INFO
  loggers = ["akka.event.jul.JavaLogger"]
  logging-filter = "akka.event.jul.JavaLoggingFilter"
}
# Disable legacy metrics in akka-cluster.
#akka.cluster.metrics.enabled=off
# Enable metrics extension in akka-cluster-metrics.
#akka.extensions=["akka.cluster.metrics.ClusterMetricsExtension"]
akka.cluster.jmx.multi-mbeans-in-same-jvm = on

my-dispatcher {
  # Dispatcher is the name of the event-based dispatcher
  type = Dispatcher
  # What kind of ExecutionService to use
  executor = "fork-join-executor"
  # Configuration for the fork join pool
  fork-join-executor {
    # Min number of threads to cap factor-based parallelism number to
    parallelism-min = 1
    # Parallelism (threads) ... ceil(available processors * factor)
    parallelism-factor = 2.0
    # Max number of threads to cap factor-based parallelism number to
    parallelism-max = 2
  }
  # Throughput defines the maximum number of messages to be
  # processed per actor before the thread jumps to the next actor.
  # Set to 1 for as fair as possible.
  throughput = 100
}
